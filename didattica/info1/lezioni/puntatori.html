<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<h1 id="la-memoria-e-il-c">La memoria e il C</h1>
<p>Cercheremo di capire come il C gestisce la memoria. Perché ce ne dovrebbe fregare?</p>
<p>Perché imparando a gestire la memoria possiamo lavorare con strutture dati la cui dimensione è <em>variabile</em> durante l'esecuzione! Niente più array sovradimensionati, o troppo piccoli, o troppo grandi! In molti altri linguaggi di &quot;più alto livello&quot; (Python, Ruby, Lisp) è possibile far variare, per esempio, la dimensione degli array durante l'esecuzione del programma, senza preoccuparsi dei dettagli. Il C richiede più attenzione, e più consapevolezza dei meccanismi con cui le variabili vengono gestite.</p>
<h2 id="mamma-da-dove-nascono-le-variabili-e-quando-muoiono-dove-vanno">Mamma, da dove nascono le variabili? E quando muoiono, dove vanno?</h2>
<p>Consideriamo il seguente codice:</p>
<pre class="sourceCode c"><code class="sourceCode c">
<span class="dt">int</span> main()
{
 <span class="dt">int</span> a;
    
 <span class="kw">for</span> (a=<span class="dv">0</span>;a&lt;<span class="dv">10</span>;a++)
  printf (<span class="st">&quot;%i</span><span class="ch">\t</span><span class="st">&quot;</span>,a);
}</code></pre>
<p>Concentriamoci su: <code>int a</code>. In che modo questa dichiarazione viene interpretata dal compilatore? Come sappiamo, tutti i dati che servono all'esecuzione del programma vengono memorizzati nella... <em>memoria</em>. Ricordiamo che, per quello che ci riguarda, la memoria può essere modellizzata come una tabella di celle numerate, nelle quali è possibile scrivere, e dalle quali è possibile leggere. Ogni cella può contenere una sequenza di bit di una certa dimensione, tipicamente una potenza di 2 (8, 16, 32 bit)</p>
<p>In un certo momento, lo stato della memoria sarà qualcosa del tipo:</p>
<table>
<thead>
<tr class="header">
<th align="left">Indirizzo</th>
<th align="left">Dato</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">00000000</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">00001100</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">01011010</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">10100100</td>
</tr>
<tr class="odd">
<td align="left">.....</td>
<td align="left">........</td>
</tr>
<tr class="even">
<td align="left">100</td>
<td align="left">00101010</td>
</tr>
<tr class="odd">
<td align="left">.....</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Per scrivere un dato, è necessario fornire il numero della riga (<em>indirizzo</em>) e il dato da scrivere (<em>dato</em>)</p>
<p>Ok, torniamo al problema di come nascono le variabili, e dell'interpretazione della dichiarazione <code>int a</code>. Quando il compilatore incontra <code>int a</code>, capisce che, nel codice che segue, faremo riferimento ad <code>a</code> come ad una variabile di valore intero. Quello che il compilatore fa è di prenotare (<em>allocare</em>) una locazione di memoria per contenere il valore della variabile <code>a</code>. Se una cella sola non basta, perché per esempio gli interi che utilizziamo necessitano di 16 bit per essere rappresentati, mentre le celle della memoria sono a singolo byte (8 bit), il compilatore alloca tante celle quante ne servono per memorizzare il dato. Ma cosa vuole dire che il compilatore <em>alloca</em> memoria per la variabile <code>a</code>? Vuol dire che sceglie un pezzetto di memoria per contenere <code>a</code> (un erto numero di celle contigue), e <em>si segna</em> da qualche parte che quella memoria è <em>riservata</em> ad <code>a</code>. Cioè, da qualche parte, il compilatore si segna questa informazione: &quot;la variabile <code>a</code> è memorizzata in due celle, a partire dall 100&quot;. In questo modo, se dovesse incontrare un'altra dichiarazione, tipo <code>char b</code>, avrebbe tutta l'informazione per allocare una zona di memoria diversa. Ora: successivamente, tutte le operazioni che utilizzano il valore di <code>a</code> vengono trasformate in letture alle celle 100 e 101, e tutte quelle che modificano il valore di <code>a</code> vengono tradotte in scritture alle stesse celle.</p>
<p>E per gli array?</p>
<pre><code>int a[10];</code></pre>
<p>Quando il compilatore incontra questa dichiarazione, alloca spazio contiguo sufficiente per memorizzare tutti gli elementi dell'array (in questo caso, ad esempio, continuando a considerare l'ipotesi che un intero occupi due celle di memoria, il compilatore potrebbe allocare la memoria dall'indirizzo 100 al 119.</p>
<p>Notare come tutte queste cose avvengano al momento della compilazione. Il motivo per cui non abbiamo potuto utilizzare, fino ad ora, strutture dati dinamiche, tipo array la cui dimensione è stabilita <em>durante l'esecuzione</em> (a <em>runtime</em>) piuttosto che durante la compilazione (a <em>compile time</em>), è che abbiamo lasciato fare tutto il lavoro di allocazione della memoria al compilatore. E' il momento di assurmerci le nostre responsabilità, e prendere in mano il nostro destino.</p>
<h2 id="lallocazione-dinamica-della-memoria">L'allocazione dinamica della memoria</h2>
<p>Nella libreria standard C esiste una funzione che consente di <em>riservare</em> della memoria durante l'esecuzione del programma. L'unica informazione richiesta è la quantità di memoria che serve. La funzione si chiama <code>malloc</code>. E così la chiamata:</p>
<pre><code>malloc(10)</code></pre>
<p>alloca 10 parole di memoria. <code>malloc</code> controlla se in memoria ci sono 10 celle libere. Se sì, si segna in una tabella che sono occupate e... attenzione: <em>restituisce l'indirizzo della prima delle celle occupate</em>. L'indirizzo? E cosa me ne faccio, dell'indirizzo?</p>
<h2 id="i-puntatori">I puntatori</h2>
<p>Si da il caso che, in C, sia possibile accedere direttamente alla cella di memoria ad un certo indirizzo, se lo si conosce. Capiamoci con un caso concreto. Consideriamo la nostra solita dichiarazione:</p>
<pre><code>int c;</code></pre>
<p>Abbiamo capito che il compilatore assocerà al nome di variabile <code>c</code> un indirizzo in memoria. Ebbene, esiste il modo di sapere qual è questo indirizzo! Questo è possibile con l'operatore <code>&amp;</code>: <code>&amp;c</code> è un espressione che ha il valore dell'indirizzo in memoria della variabile <code>c</code>! E che ce ne facciamo, dell'indirizzo di <code>c</code>, una volta che l'abbiamo ottenuto? Beh, possiamo per esempio memorizzarlo in una variabile:</p>
<pre><code>a = &amp;c;</code></pre>
<p>Ma che di che tipo deve essere, <code>a</code>? Lo vediamo tra un attimo. L'indirizzo in memoria di una variabile si chiama anche <em>puntatore</em> a quella variabile. Dopo l'assegnamento di sopra, <code>a</code> contiene il puntatore a <code>c</code>. Si dice anche che <em><code>a</code> punta a <code>c</code></em>. Ora chiediamoci: che altro posso fare, con un puntatore? Un'altra cosa notevole che posso fare è <em>accedere alla locazione di memoria alla quale il puntatore punta</em>. Saltando l'intermediazione del compilatore! Questo è possibile tramite l'operatore <code>*</code>. Immaginiamo di voler scrivere il valore <code>1</code> alla locazione di memoria il cui indirizzo è il valore della variabile <code>a</code>. La cosa si fa così:</p>
<pre><code>*a = 1;</code></pre>
<p>In questo modo abbiamo scritto <code>1</code> alla locazione di memoria alla quale punta <code>a</code>. Ma sopra avevamo fatto in modo che <code>a</code> 'puntasse' a <code>c</code>. Quindi, secondo voi, cosa stamperà la seguente chiamata a <code>printf</code>?</p>
<pre><code>printf (&quot;%i&quot;,c);</code></pre>
<p>L'operatore <code>*</code> si può usare anche per leggere dalla memoria:</p>
<pre><code>printf (&quot;%i&quot;,*a);</code></pre>
<p>Ok, ora poniamoci il problema del tipo della variabile <code>a</code>. Che cosa contiene la variabile <code>a</code>? Contiene un puntatore ad un valore intero. Quindi l'espressione <code>*a</code> è un valore intero. Cioè <code>*a</code> è un <code>int</code>. Allora, se vogliamo dichiarare <code>a</code> come puntatore ad intero, la dichiarazione è:</p>
<pre><code>int *a;</code></pre>
<p>Bene. Torniamo alla <code>malloc</code>. Abbiamo detto che malloc ritorna l'indirizzo alla prima cella di memoria allocata. Se questo è vero, potremmo &quot;creare&quot; autonomamente una variabile intera, dichiarando un puntatore, allocando la memoria per contenere il dato, e facendo puntare il puntatore a quella zona di memoria. E' molto più facile a farsi:</p>
<pre class="sourceCode c"><code class="sourceCode c">
 <span class="dt">int</span> *p;  

 p=malloc(Hey un momento!);</code></pre>
<p>Hey, un momento? Quanta memoria mi serve, per contenere un intero? In generale, non siamo tenuti a saperlo. Per fortuna esiste una funzione speciale, <code>sizeof</code>, con cui possiamo ottenere quest'informazione. Il numero di parole che serve per contenere un intero è quindi <code>sizeof(int)</code>. E, quindi, per allocare memoria per un intero, facciamo così:</p>
<pre><code>p=malloc(sizeof(int));</code></pre>
<p>A questo punto, possiamo usare <code>*p</code> per accedere alla zona di memoria che abbiamo appena allocato, e che contiene un intero. Non è fantastico?</p>
<pre><code>*p=1;
(*p)++
printf (&quot;%i&quot;,*p)</code></pre>
<h2 id="e-gli-array">E gli array?</h2>
<p>Ebbene, abbiamo un puntatore, memorizzato nella variabile <code>c</code>, di tipo puntatore. Sappiamo che <code>*c</code> ci consente di accedere alla cella di memoria &quot;puntata&quot; da <code>c</code>. Ma a noi piace esplorare. E quindi ci chiediamo: che succede se cerchiamo di accedere a <code>c+1</code>? Facciamo questo esperimento:</p>
<pre><code>int a[2]={10,20};
c = &amp;a[0];
printf (&quot;%i&quot;,*c);
printf (&quot;%i&quot;,*(c+1));</code></pre>
<p>Cosa succede? Succede che gli elementi dell'array <code>a</code>, come possiamo immaginare, sono memorizzati, in memoria, tutti in sequenza. Quindi, se otteniamo l'indirizzo del primo elemento, <code>a[0]</code>, che d'ora in poi chiamareremo <em>base</em> dell'array, possiamo ottenere gli indirizzi degli altri, sommando alla base un valore intero. Ora, aprite bene gli occhi, ecco un paio di equivalenze notevoli in C:</p>
<pre><code>a == &amp;a[0]
a[n] == *(a+n)</code></pre>
<p>Queste due uguaglianze sono sempre vere! Cioè: se abbiamo dichiarato un array <code>a</code> con <code>int a[10]</code>, l'espressione <code>a</code> da sola rappresenta l'indirizzo al primo elemento, cioè la base! Quindi: quando dichiariamo un array, stiamo dichiarando un puntatore e contemporaneamente, stiamo chiedendo al compilatore di allocare la memoria necessaria per contenere gli elementi dell'array e di far puntare il puntatore all'inizio della zona di memoria allocata. Beh, se ci riflettiamo, ora sappiamo farlo anche noi, senza bisogno dell'aiuto del compilatore. E, soprattutto, possiamo farlo a run time!</p>
<p>Ecco un esempio:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main()
{
    <span class="dt">int</span> *a;
    <span class="dt">int</span> i,n;
    printf (<span class="st">&quot;quanto lo vuoi lungo, l&#39;array?&quot;</span>);
    scanf(<span class="st">&quot;%i&quot;</span>,&amp;n);                                 
    a=malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>)*n);    <span class="co">// alloca lo spazio per l&#39;array, e fai puntare</span>
                                <span class="co">// a allo spazio allocato</span>
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n;i++)           <span class="co">// riempi l&#39;array di valori</span>
        a[i]=i;                 
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n;i++)           <span class="co">// stampa i valori dell&#39;array</span>
        printf(<span class="st">&quot;%i&quot;</span>,a[i])
}</code></pre>
<p>Dal codice sopra, possiamo finalmente anche capire la ragione dell'operatore <code>&amp;</code> prima della variabile in cui vogliamo memorizzare il dato richiesto dalla <code>scanf</code>. Il fatto è questo: in C, come abbiamo visto, tutte le variabili sono passate <em>per valore</em>. Cioè, chiamiamo una funzione, <code>f(e)</code>, dove <code>e</code> è una qualsiasi espressione, quello che succede è che: - il valore di <code>e</code> viene valutato - una <em>copia</em> del valore di <code>e</code> viene passata a <code>f</code> Quindi, se <code>e</code> è una variabile, a <code>f</code> viene passato il valore di <code>e</code>, ed <code>f</code> non può in nessun modo cambiare il contenuto della variabile <code>e</code>. &quot;Ma <code>scanf</code> il valore lo cambia!&quot;, vi sento dire! E avete ragione! Ma la cosa va così: a <code>scanf</code> non viene passato il valore della variabile nella quale memorizzare il dato, bensì <em>un puntatore ad essa</em>! In questo modo, <code>scanf</code> può accedere direttamente alla zona di memoria in cui è memorizzata la variabile in cui mettere il dato. Proviamo a fare qualcosa di analogo, e che non potremmo fare senza puntatori: una funzione che scambia il valore di due variabili.</p>
<pre><code>void f(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}</code></pre>
<p>Et voilà!</p>
</body>
</html>
