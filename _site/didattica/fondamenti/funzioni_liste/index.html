
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Gestione Liste</title>
    
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
    


  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-36402304-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>




  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">Appunti Sparsi</a>
          <ul class="nav">
            
            
            


  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
  
    
      
    
  
    
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>Gestione Liste </h1>
</div>

<div class="row">
  <div class="span12" style="width: 90%">
    <p>Fino ad ora, gestire le liste è stato qualcosa di molto <em>fastidioso</em>, nell&#8217;accezione di <em>poco scalabile</em>. Ogni nuovo elemento aggiunto richiede di gestire un ulteriore livello di redirezione (<code>-&gt;</code>), e in breve tempo il tutto diventa intrattabile. Vedremo ora come usare il potere dell&#8217;induzione ricorsiva per liberarci da questa sofferenza.</p>

<p>Osservazione: non vi sembra che le liste abbiano qualcosa di inquietantemente <em>ricorsivo</em>?</p>

<p>Immaginiamo di dover realizzare una funzione che stampa gli elementi di una lista di caratteri. Ci viene passato il puntatore al primo nodo. Mi pare che potremmo fare così: stampiamo il carattere del nodo che ci viene passato, e poi stampiamo la lista che ci resta. Come facciamo ad ottenere la lista che ci resta? E&#8217; facile: prendiamo il puntatore al nodo successivo! Il puntatore al nodo successivo <em>identifica</em> un&#8217;altra lista: precisamente la lista dei caratteri dopo quello corrente.</p>

<pre><code> |P0|--&gt;|&#39;c&#39;||---+
                 |
 |P1|    -------&gt;+----&gt;|&#39;i&#39;||----&gt;|&#39;a&#39;||----&gt;|&#39;o&#39;||-----&gt;NULL</code></pre>

<p>Nel caso sopra, al puntatore <code>P0</code> corrisponde la lista <code>[&#39;c&#39;,&#39;i&#39;,&#39;a&#39;,&#39;o&#39;]</code>, mentre al puntatore <code>P1</code> corrisponde la lista <code>[&#39;i&#39;,&#39;a&#39;,&#39;o&#39;]</code>.</p>

<p>Poniamoci allora il problema di come scrivere una funzione che stampi gli elementi di una lista. Ebbene, chiediamoci:</p>

<ol>
<li><em>se fossimo</em> in grado di stampare una lista di lunghezza <code>N</code>, saremmo in grado di stampare anche una lista di lunghezza <code>N+1</code>?</li>

<li>siamo in grado di stampare una lista di lunghezza <code>0</code>?</li>
</ol>

<p>Se ci sentiamo di rispondere &#8216;sì&#8217; ad entrambe le domande sopra, allora siamo in grado di stampare qualsiasi lista!</p>

<p>Scriviamo quindi, per prima cosa, una funzione che ci dimostri che sappiamo rispondere alla domanda 2. Come facciamo a sapere che una lista è di lunghezza <code>0</code>? Semplice: il puntatore al primo nodo punterà a <code>NULL</code>!</p>

<p>Ecco allora la funzione che stampa la nostra lista:</p>
<div class='highlight'><pre><code class='c'><span class='k'>struct</span> <span class='n'>nodo</span>
<span class='p'>{</span>
    <span class='kt'>char</span> <span class='n'>dato</span><span class='p'>;</span>
    <span class='k'>struct</span> <span class='n'>nodo</span> <span class='o'>*</span><span class='n'>prossimo</span><span class='p'>;</span>
<span class='p'>};</span>

<span class='kt'>void</span> <span class='nf'>stampa_lista</span><span class='p'>(</span><span class='k'>struct</span> <span class='n'>nodo</span> <span class='o'>*</span><span class='n'>lista</span><span class='p'>)</span>
<span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>lista</span><span class='o'>==</span><span class='nb'>NULL</span><span class='p'>)</span>
    <span class='p'>{</span>
        <span class='n'>printf</span> <span class='p'>(</span><span class='s'>&quot;</span><span class='se'>\n</span><span class='s'>&quot;</span><span class='p'>);</span>
        <span class='k'>return</span><span class='p'>;</span>
    <span class='p'>}</span>

    <span class='n'>printf</span> <span class='p'>(</span><span class='s'>&quot;%c&quot;</span><span class='p'>,</span><span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>dato</span><span class='p'>);</span>
    <span class='n'>stampa_lista</span><span class='p'>(</span><span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='p'>);</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>Proviamo ad applicare lo stesso concetto per scrivere una funzione che calcola la lunghezza di una lista. Il ragionamento è questo:</p>

<ol>
<li>se la lista è vuota (cioè se il puntatore al primo elemento è <code>NULL</code>), la lunghezza è <code>0</code></li>

<li>altrimenti, la lunghezza è <code>1</code> (l&#8217;elemento corrente) più la lunghezza della lista successiva al primo elemento.</li>
</ol>

<p>Per comodità, ci riferiremo d&#8217;ora in poi al primo elemento della lista come alla <em>testa</em>, e al resto della lista come alla <em>coda</em>.</p>
<div class='highlight'><pre><code class='c'><span class='kt'>int</span> <span class='nf'>len</span><span class='p'>(</span><span class='k'>struct</span> <span class='n'>nodo</span> <span class='o'>*</span><span class='n'>lista</span><span class='p'>)</span>
<span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>lista</span><span class='o'>==</span><span class='nb'>NULL</span><span class='p'>)</span>
        <span class='k'>return</span> <span class='mi'>0</span><span class='p'>;</span>
    <span class='k'>return</span> <span class='mi'>1</span> <span class='c1'>// lunghezza della testa (1)</span>
        <span class='o'>+</span><span class='n'>len</span><span class='p'>(</span><span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='p'>);</span> <span class='c1'>// lunghezza della coda (len(lista-&gt;prossimo))</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>Ora cerchiamo di implementare la funzione <code>append</code> che tanto invidiamo ai nostri amici pythonisti. Il ragionamento, in questo caso, è:</p>

<ol>
<li>se la <em>coda</em> della lista è vuota (cioè se la lista è composta solo dalla <em>testa</em>), allora aggiungi direttamente il nuovo nodo alla testa</li>

<li>altrimenti, fai <code>append</code> del nuovo nodo sulla <em>coda</em>.</li>
</ol>
<div class='highlight'><pre><code class='c'><span class='kt'>void</span> <span class='nf'>append</span><span class='p'>(</span><span class='k'>struct</span> <span class='n'>nodo</span> <span class='o'>*</span><span class='n'>lista</span><span class='p'>,</span> <span class='kt'>char</span> <span class='n'>c</span><span class='p'>)</span>
<span class='p'>{</span>

    <span class='k'>if</span> <span class='p'>(</span><span class='n'>lista</span><span class='o'>==</span><span class='nb'>NULL</span><span class='p'>)</span>

    <span class='k'>if</span> <span class='p'>(</span><span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='o'>==</span><span class='nb'>NULL</span><span class='p'>)</span>
    <span class='p'>{</span>
        <span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='o'>=</span><span class='n'>malloc</span><span class='p'>(</span><span class='k'>sizeof</span><span class='p'>(</span><span class='k'>struct</span> <span class='n'>nodo</span><span class='p'>));</span>
        <span class='p'>(</span><span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='p'>)</span><span class='o'>-&gt;</span><span class='n'>dato</span><span class='o'>=</span><span class='n'>c</span><span class='p'>;</span>
        <span class='p'>(</span><span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='p'>)</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='o'>=</span><span class='nb'>NULL</span><span class='p'>;</span>
        <span class='k'>return</span><span class='p'>;</span>
    <span class='p'>}</span>
    <span class='n'>append</span><span class='p'>(</span><span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='p'>,</span> <span class='n'>c</span><span class='p'>);</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>Ora poniamoci finalmente il problema di stampare il contenuto della nostra lista al contrario. Anche qui possiamo avvalerci del ragionamento ricorsivo, in questo modo:</p>

<ol>
<li>se la lista è vuota, non stampare niente</li>

<li>se la lista non è vuota, prendine la <em>coda</em>, stampala al contrario, e <em>poi</em> stampa la <em>testa</em>.</li>
</ol>
<div class='highlight'><pre><code class='c'><span class='kt'>void</span> <span class='nf'>stampa_lista_contrario</span><span class='p'>(</span><span class='k'>struct</span> <span class='n'>nodo</span> <span class='o'>*</span><span class='n'>lista</span><span class='p'>)</span>
<span class='p'>{</span>
    <span class='k'>if</span> <span class='p'>(</span><span class='n'>lista</span><span class='o'>==</span><span class='nb'>NULL</span><span class='p'>)</span>
        <span class='k'>return</span><span class='p'>;</span>
    <span class='n'>stampa_lista_contrario</span><span class='p'>(</span><span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='p'>);</span>
    <span class='n'>printf</span> <span class='p'>(</span><span class='s'>&quot;%c&quot;</span><span class='p'>,</span><span class='n'>lista</span><span class='o'>-&gt;</span><span class='n'>dato</span><span class='p'>);</span>
<span class='p'>}</span>
</code></pre>
</div>
<p><a href='nodo.c'>Qui</a> trovate un esempio completo di utilizzo delle nostre funzioni&#8230;</p>

<h3 id='implementazione_iterativa'>Implementazione iterativa</h3>

<p>La ricorsione è un mezzo molto potente ed espressivo, e consente di risolvere alcuni problemi in modo estremamente elegante. Ricordiamo però che l&#8217;esecuzione di una funzione ricorsiva può essere anche molto onerosa. Ad esempio, la profondità di ricorsione della nostre funzioni è pari al numero degli elementi della lista: se vogliamo aggiungere un elemento in fondo ad una lista di 1.000.000 elementi con la nostra <code>append</code>, ci ritroveremo con un 1.000.000 di chiamate annidate, e con i corrispondenti record di attivazione in cima alla pila (vale la pena di notare che alcuni compilatori sono in grado di ottimizzare un particolare tipo di ricorsione, detta &#8221;<a href='http://en.wikipedia.org/wiki/Tail_call'>in coda</a>&#8221;, in modo che questa <code>esplosione</code> sulla pila non avvenga). Proviamo quindi ad implementare, senza ricorrere alla ricorsione (ahah), le funzioni di gestione delle liste viste sopra. Partiamo da quella forse più semplice: la <code>len</code>. L&#8217;idea è questa: prendiamo una variabile, <code>i</code>, che utilizziamo in questo modo: inizialmente le assegnamo come valore la testa della lista (cioè, lo ricordiamo, l&#8217;indirizzo al primo elemento):</p>
<div class='highlight'><pre><code class='c'><span class='kt'>int</span> <span class='nf'>len</span><span class='p'>(</span><span class='k'>struct</span> <span class='n'>node</span> <span class='o'>*</span><span class='n'>l</span><span class='p'>)</span>
<span class='p'>{</span>
    <span class='k'>struct</span> <span class='n'>node</span> <span class='o'>*</span><span class='n'>i</span><span class='p'>;</span>
    <span class='n'>i</span><span class='o'>=</span><span class='n'>l</span><span class='p'>;</span>
    <span class='p'>[...]</span>
</code></pre>
</div>
<p>A questo punto ci troviamo in questa situazione:</p>

<pre><code>l---+
    |   
    +---&gt;| ||----&gt;| ||----&gt;| ||-----&gt;NULL
    |
i---|</code></pre>

<p>se ora eseguiamo il seguente assegnamento:</p>
<div class='highlight'><pre><code class='c'>    <span class='n'>i</span> <span class='o'>=</span> <span class='n'>i</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='p'>;</span>
</code></pre>
</div>
<p>la situazione diventa questa:</p>

<pre><code>l---+
    |   
    +---&gt;| ||--+-&gt;| ||----&gt;| ||----&gt;NULL
               |
i--------------|</code></pre>

<p>cioè <code>i</code> punta al secondo elemento. La strategia è quella di far avanzare <code>i</code>, fino a farlo puntare a <code>NULL</code>, e nel frattempo contare quanti salti si sono fatti. Riassumiamo tutto in un ciclo <code>for</code>:</p>
<div class='highlight'><pre><code class='c'><span class='p'>[...]</span>
<span class='kt'>int</span> <span class='n'>lunghezza</span><span class='p'>;</span>
<span class='k'>for</span> <span class='p'>(</span><span class='n'>lunghezza</span><span class='o'>=</span><span class='mi'>0</span><span class='p'>,</span> <span class='n'>i</span><span class='o'>=</span><span class='n'>l</span><span class='p'>;</span><span class='n'>i</span><span class='o'>!=</span><span class='nb'>NULL</span><span class='p'>;</span><span class='n'>i</span><span class='o'>=</span><span class='n'>i</span><span class='o'>-&gt;</span><span class='n'>prossimo</span><span class='p'>)</span>
    <span class='p'>;</span>
</code></pre>
</div>
<p>A questo punto, quando il ciclo termina, in <code>lunghezza</code> c&#8217;è la lunghezza della lista, che possiamo ritornare.</p>

<p><a href='liste_iter.c'>Qui</a> c&#8217;è il codice completo delle funzioni iterative.</p>

    
      


  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_shortname = 'appunti-sparsi'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>





    
  </div>
</div>


      </div>

      <footer>
        <p>&copy;  2012 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

  </body>
</html>

